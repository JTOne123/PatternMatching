<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ output extension=".cs" #>
using System;

namespace Patterns.Containers
{
<#for (int i = 2; i < 16; i++){#>
	<# var typeSig = string.Join(", ", Enumerable.Range(1, i).Select(n => "T" + n)); #>
public sealed class Union<<#=typeSig#>>: IEquatable<Union<<#=typeSig#>>>
	{
		public object Value { get; private set; }
		<#for (int j = 1; j <=i; j++){#>
public T<#=j#> Value<#=j#> { get; private set; }
		<#}#>

		<#for (int j = 1; j <=i; j++){#>
public Union(T<#=j#> value)
        {
            Value<#=j#> = value;
			Value = value;
        }
		<#}#>

		<#for (int j = 1; j <=i; j++){#>
public static explicit operator T<#=j#>(Union<<#=typeSig#>> value)
        {
            return value.Value<#=j#>;
        }
		<#}#>

		<#for (int j = 1; j <=i; j++){#>
public static implicit operator Union<<#=typeSig#>>(T<#=j#> value)
        {
            return new Union<<#=typeSig#>>(value);
        }
		<#}#>

        public override bool Equals(object obj)
	    {
            if (ReferenceEquals(this, obj))
                return true;

		    var other = obj as Union<<#=typeSig#>>;
            return !ReferenceEquals(other, null) && Equals(other);
	    }
    
        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        public bool Equals(Union<<#=typeSig#>> other)
        {
            if (other == null)
                return false;

            if (ReferenceEquals(this, other))
                return true;

            return Value.Equals(other.Value);
        }

        public static bool operator ==(Union<<#=typeSig#>> left, Union<<#=typeSig#>> right)
        {
            return !ReferenceEquals(left, null) && !ReferenceEquals(right, null) && left.Equals(right);
        }

        public static bool operator !=(Union<<#=typeSig#>> left, Union<<#=typeSig#>> right)
        {
            return !(left == right);
        }
    }

<#}#>
}